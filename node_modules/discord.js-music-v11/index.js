const YoutubeDL = require('youtube-dl');
const Discord = require(`discord.js`);
const stream = require('youtube-audio-stream');
const ytdl = require('ytdl-core');
var num = Math.floor(Math.random() * 9000000) + 1000000;


/**
 * Takes a discord.js client and turns it into a music bot.
 * Thanks to 'derekmartinez18' for helping.
 * 
 * @param {Client} client - The discord.js client.
 * @param {object} options - (Optional) Options to configure the music bot. Acceptable options are:
 * 							prefix: The prefix to use for the commands (default '!').
 * 							global: Whether to use a global queue instead of a server-specific queue (default false).
 * 							maxQueueSize: The maximum queue size (default 20).
 * 							anyoneCanSkip: Allow anybody to skip the song.
 * 							clearInvoker: Clear the command message.
 * 							volume: The default volume of the player.
 */
module.exports = function (client, options) {
	// Get all options.
	let PREFIX = (options && options.prefix) || '%';
	let GLOBAL = (options && options.global) || false;
	let MAX_QUEUE_SIZE = (options && options.maxQueueSize) || 20;
	let DEFAULT_VOLUME = (options && options.volume) || 50;
	let ALLOW_ALL_SKIP = (options && options.anyoneCanSkip) || false;
	let CLEAR_INVOKER = (options && options.clearInvoker) || true;

	// Create an object of queues.
	let queues = {};
	var player
	var suffix;
	// Catch message events.
	client.on('message', msg => {
		const message = msg.content.trim();
		// Check if the message is a command.
		if (message.toLowerCase().startsWith(PREFIX.toLowerCase())) {
			// Get the command and suffix.
			const command = message.substring(PREFIX.length).split(/[ \n]/)[0].toLowerCase().trim();
			const suffix = message.substring(PREFIX.length + command.length).trim();

			// Process the commands.
			switch (command) {
				case 'play':
					return play(msg, suffix);
				case 'skip':
					return skip(msg, suffix);
				case 'queue':
					return queue(msg, suffix);
				case 'pause':
					return pause(msg, suffix);
				case 'resume':
					return resume(msg, suffix);
				case 'volume':
					return volume(msg, suffix);
				case 'leave':
					return leave(msg, suffix);
				case 'clearqueue':
					return clearqueue(msg, suffix);
			}
			if (CLEAR_INVOKER === (true)) {
				msg.delete();
			}
		}
	});

	/**
	 * Checks if a user is an admin.
	 * 
	 * @param {GuildMember} member - The guild member
	 * @returns {boolean} - 
	 */
	function isAdmin(member) {
		return member.hasPermission("ADMINISTRATOR");
	}

	function pluck(array) {
		return array.map(function (item) {
			return item["name"];
		});
	}

	function hasRole(member, role) {
		if (pluck(member.roles).includes(role)) {
			return true;
		} else {
			return false;
		}
	}
	/**
	 * Checks if the user can skip the song.
	 * 
	 * @param {GuildMember} member - The guild member
	 * @param {array} queue - The current queue
	 * @returns {boolean} - If the user can skip
	 */
	function canSkip(member, queue) {
		if (ALLOW_ALL_SKIP) return true;
		else if (queue[0].requester === member.id) return true;
		else if (isAdmin(member)) return true;
		else return false;
	}

	/**
	 * Gets the song queue of the server.
	 * 
	 * @param {integer} server - The server id. 
	 * @returns {object} - The song queue.
	 */
	function getQueue(server) {
		// Check if global queues are enabled.
		if (GLOBAL) server = '_'; // Change to global queue.

		// Return the queue.
		if (!queues[server]) queues[server] = [];
		return queues[server];
	}

	/**
	 * The command for adding a song to the queue.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 * @returns {<promise>} - The response edit.
	 */
	function play(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				// Make sure the user is in a voice channel.
				msg.delete();
				if (msg.member.voiceChannel === undefined) return musicchan.send('**Join a channel ni:b::b:a**');

				// Make sure the suffix exists.
				if (!suffix) return musicchan.send('**Can\'t play nothing m9**');

				// Get the queue.
				const queue = getQueue(msg.guild.id);

				// Check if the queue has reached its maximum size.
				if (queue.length >= MAX_QUEUE_SIZE) {
					return musicchan.send('**Queue\'s full**');
				}

				if (suffix.includes('https://soundcloud')) {
					return musicchan.send('**Nah m8, ain\'t nothing works from SoundCloud**')
				}
				// Get the video information.
				musicchan.send(`**Searching for ${suffix}...** *by ${msg.author.username}*`).then(response => {
					var searchstring = suffix
					if (!suffix.toLowerCase().startsWith('http')) {
						searchstring = 'gvsearch1:' + suffix;
					}

					YoutubeDL.getInfo(searchstring, ['-q', '--no-warnings', '--force-ipv4'], (err, info) => {
						// Verify the info.

						if (err || info.format_id === undefined || info.format_id.startsWith('0')) {
							console.log(err);
							console.log(`\n${info}`);
							// console.log(`Error1: ${err}\n Error 2: ${info.format_id}`);
							return response.edit(`**Fuckin no idea what that was ${msg.author.username}...**`);
						}

						info.requester = msg.author.id;

						// Queue the video.
						response.edit(`**Queued: ** ${info.title} *by ${msg.author.username}*`).then(() => {
							player = msg.author.username
							queue.push(info);
							// Play if only one element in the queue.
							if (queue.length === 1) executeQueue(msg, queue);
						}).catch(console.log);
					});

				}).catch(console.log);
			} else musicchan.send(`**Unauthorised**`);
		}
	}


	/**
	 * The command for skipping a song.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 * @returns {<promise>} - The response message.
	 */
	function skip(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				msg.delete()
				// Get the voice connection.
				const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
				if (voiceConnection === null) return musicchan.send('**No music being played.**');

				// Get the queue.
				const queue = getQueue(msg.guild.id);

				if (!canSkip(msg.member, queue)) return musicchan.send('**You cannot skip this as you didn\'t queue it.**').then((response) => {
					response.delete(5000);
				});

				// Get the number to skip.
				let toSkip = 1; // Default 1.
				if (!isNaN(suffix) && parseInt(suffix) > 0) {
					toSkip = parseInt(suffix);
				}
				toSkip = Math.min(toSkip, queue.length);

				// Skip.
				queue.splice(0, toSkip - 1);

				// Resume and stop playing.
				const dispatcher = voiceConnection.player.dispatcher;
				if (voiceConnection.paused) dispatcher.resume();
				dispatcher.end();

				musicchan.send('**Skipped **' + toSkip + ' by this ni:b::b:a ' + msg.author.username + '!');
			} else return
		}
	}

	/**
	 * The command for listing the queue.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 */
	function queue(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			// Get the queue.
			const queue = getQueue(msg.guild.id);

			// Get the queue text.
			const text = queue.map((video, index) => (
				(index + 1) + ': ' + video.title
			)).join('\n');

			// Get the status of the queue.
			let queueStatus = 'Stopped';
			const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
			if (voiceConnection !== null) {
				const dispatcher = voiceConnection.player.dispatcher;
				queueStatus = dispatcher.paused ? 'Paused' : 'Playing';
			}

			// Send the queue and status.
			musicchan.send('Queue (' + queueStatus + '):\n' + text);
		}
	}

	/**
	 * The command for pausing the current song.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 * @returns {<promise>} - The response message.
	 */
	function pause(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				// Get the voice connection.
				const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
				if (voiceConnection === null) return musicchan.send('Ah the sweet sound of nothing being played...');

				if (!isAdmin(msg.member))
					return musicchan.send('**You are not authorized to use this.**');

				// Pause.
				musicchan.send('Playback paused.');
				const dispatcher = voiceConnection.player.dispatcher;
				if (!dispatcher.paused) dispatcher.pause();
			} else return;
		}
	}

	/**
	 * The command for leaving the channel and clearing the queue.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 * @returns {<promise>} - The response message.
	 */
	function leave(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				if (isAdmin(msg.member)) {
					msg.delete();
					const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
					if (voiceConnection === null) return musicchan.send('**Where the fuck do you think I am?**');
					// Clear the queue.
					const queue = getQueue(msg.guild.id);
					queue.splice(0, queue.length);

					// End the stream and disconnect.
					voiceConnection.player.dispatcher.end();
					voiceConnection.disconnect();
					musicchan.send('**Fine. Didn\'t wanna play anything anyway...**');
				} else {
					musicchan.send('No perms for that ma dude');
				}
			}
		}
	}

	/**
	 * The command for clearing the song queue.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 */
	function clearqueue(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				if (isAdmin(msg.member)) {
					const queue = getQueue(msg.guild.id);

					queue.splice(0, queue.length);
					musicchan.send('Queue cleared!');
				} else {
					musicchan.send('You don\'t have permission to use that command!');
				}
			}
		}
	}

	/**
	 * The command for resuming the current song.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 * @returns {<promise>} - The response message.
	 */
	function resume(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				// Get the voice connection.
				const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
				if (voiceConnection === null) return musicchan.send('Ah the sweet sound of nothing being played...');

				if (!isAdmin(msg.member))
					return musicchan.send('You are not authorized to use this.');

				// Resume.
				musicchan.send('Playback resumed.');
				const dispatcher = voiceConnection.player.dispatcher;
				if (dispatcher.paused) dispatcher.resume();
			}
		}
	}


	/**
	 * The command for changing the song volume.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {string} suffix - Command suffix.
	 * @returns {<promise>} - The response message.
	 */
	function volume(msg, suffix) {

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			if (hasRole(msg.member, "Music")) {
				// Get the voice connection.
				const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
				if (voiceConnection === null) return musicchan.send('No music being played.');

				if (!isAdmin(msg.member))
					return musicchan.send('You are not authorized to use this.');

				// Get the dispatcher
				const dispatcher = voiceConnection.player.dispatcher;

				if (suffix > 200 || suffix < 0) return musicchan.send('Volume out of range!').then((response) => {
					response.delete(5000);
				});
				msg.delete();
				musicchan.send("**Volume set to **" + suffix);
				dispatcher.setVolume((suffix / 100));
			}
		}
	}

	/**
	 * Executes the next song in the queue.
	 * 
	 * @param {Message} msg - Original message.
	 * @param {object} queue - The song queue for this server.
	 * @returns {<promise>} - The voice channel.
	 */
	function executeQueue(msg, queue) {

		let hextext = Math.floor(Math.random() * 16777215).toString(16);

		var musicchan = msg.guild.channels.find(mc => mc.name === 'music')
		if (musicchan) {
			// If the queue is empty, finish.
			if (queue.length === 0) {
				musicchan.send('**Finally done with your shitty music now**');

				// Leave the voice channel.
				const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
				if (voiceConnection !== null) return voiceConnection.disconnect();
			}

			new Promise((resolve, reject) => {
				// Join the voice channel if not already in one.
				const voiceConnection = client.voiceConnections.find(val => val.channel.guild.id == msg.guild.id);
				if (voiceConnection === null) {
					// Check if the user is in a voice channel.
					if (msg.member.voiceChannel) {
						msg.member.voiceChannel.join().then(connection => {
							resolve(connection);
						}).catch((error) => {
							console.log(error);
						});
					} else {
						// Otherwise, clear the queue and do nothing.
						queue.splice(0, queue.length);
						reject();
					}
				} else {
					resolve(voiceConnection);
				}
			}).then(connection => {
				// Get the first item in the queue.
				const video = queue[0];
				console.log(`Playing: ${video.title} for ${msg.author.username}`)
				// Play the video.
				musicchan.send({
					embed: {
						author: {
							name: 'Now Playing',
							icon_url: msg.guild.iconURL
						},
						color: num,
						thumbnail: {
							url: video.thumbnail
						},
						fields: [{
								name: `Song: (${video.duration})`,
								value: `[${video.title}](${video.webpage_url})`,
								inline: true
							},
							{
								name: 'For:',
								value: player,
								inline: true
							}
							// {
							// 	name: 'Duration',
							// 	value: video.duration,
							// 	inline: true
							// },
							// {
							// 	name: 'Link',
							// 	value: `[Click here for YouTube link](${video.webpage_url})`,
							// 	inline: true
							// }
						],
						footer: {
							icon_url: msg.author.avatarURL,
							text: 'Sounds lit fam'
						},
						timestamp: new Date()
					}
				}).then(() => {
					const dispatcher = connection.playStream(stream(video.webpage_url, {
						filter: 'audioonly'
					}), {
						seek: 0,
						//	volume: (DEFAULT_VOLUME / 100)
					});

					connection.on('error', (error) => {
						// Skip to the next song.
						console.log(error);
						queue.shift();
						executeQueue(msg, queue);
					});

					dispatcher.on('error', (error) => {
						// Skip to the next song.
						console.log(error);
						queue.shift();
						executeQueue(msg, queue);
					});

					dispatcher.on('end', () => {
						// Wait a second.
						setTimeout(() => {
							if (queue.length > 0) {
								// Remove the song from the queue.
								queue.shift();
								// Play the next song in the queue.
								executeQueue(msg, queue);
							}
						}, 1000);
					});
				}).catch((error) => {
					console.log(error);
				});
			}).catch((error) => {
				console.log(error);
			});
		}
	}
}

/**
 * Wrap text in a code block and escape grave characters.
 * 
 * @param {string} text - The input text.
 * @returns {string} - The wrapped text.
 */